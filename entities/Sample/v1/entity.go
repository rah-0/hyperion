package Sample

// ---------------------------------------------------------------
// The code in this file is autogenerated, do not modify manually!
// ---------------------------------------------------------------

import (
	"bytes"
	"encoding/gob"
	"errors"
	"sync"

	"github.com/google/uuid"

	"github.com/rah-0/hyperion/hconn"
	"github.com/rah-0/hyperion/model"
	"github.com/rah-0/hyperion/register"
)

const (
	Version    = "v1"
	Name       = "Sample"
	DbFileName = "SampleV1.bin"
)

const (
	FieldUuid    = 1
	FieldDeleted = 2
	FieldName    = 3
	FieldSurname = 4
)

var (
	_       register.Model = (*Sample)(nil)
	mu      sync.Mutex
	Buffer  = new(bytes.Buffer)
	Encoder = gob.NewEncoder(Buffer)
	Decoder = gob.NewDecoder(Buffer)
	Mem     []*Sample
)

func init() {
	gob.Register(&Sample{})

	// The following process initializes the encoder and decoder by preloading metadata.
	// This prevents metadata from being stored with the first encoded struct.
	// If the metadata were missing or inconsistent, decoding the struct later could fail.
	x := New()
	if err := x.Encode(); err != nil {
		panic("failed to encode type metadata: " + err.Error())
	}
	if err := x.Decode(); err != nil {
		panic("failed to decode type metadata: " + err.Error())
	}
	x.BufferReset()

	Mem = []*Sample{}

	register.RegisterEntity(&register.Entity{
		Version:    Version,
		Name:       Name,
		DbFileName: DbFileName,
		New:        New,
	})
}

type Sample struct {
	Uuid    uuid.UUID
	Deleted bool
	Name    string
	Surname string
}

func New() register.Model {
	return &Sample{}
}

func (s *Sample) WithNewUuid() {
	s.Uuid = uuid.New()
}

func (s *Sample) SetUuid(uuid uuid.UUID) {
	s.Uuid = uuid
}

func (s *Sample) GetUuid() uuid.UUID {
	return s.Uuid
}

func (s *Sample) IsDeleted() bool {
	return s.Deleted
}

func (s *Sample) SetFieldValue(field int, value any) {
	switch field {
	case FieldUuid:
		if v, ok := value.(uuid.UUID); ok {
			s.Uuid = v
		}
	case FieldDeleted:
		if v, ok := value.(bool); ok {
			s.Deleted = v
		}
	case FieldName:
		if v, ok := value.(string); ok {
			s.Name = v
		}
	case FieldSurname:
		if v, ok := value.(string); ok {
			s.Surname = v
		}
	}
}

func (s *Sample) GetFieldValue(field int) any {
	switch field {
	case FieldUuid:
		return s.Uuid
	case FieldDeleted:
		return s.Deleted
	case FieldName:
		return s.Name
	case FieldSurname:
		return s.Surname
	}
	return nil
}

func (s *Sample) Encode() error {
	mu.Lock()
	defer mu.Unlock()
	return Encoder.Encode(s)
}

func (s *Sample) Decode() error {
	mu.Lock()
	defer mu.Unlock()
	return Decoder.Decode(s)
}

func (s *Sample) BufferReset() {
	mu.Lock()
	defer mu.Unlock()
	Buffer.Reset()
}

func (s *Sample) GetBuffer() *bytes.Buffer {
	mu.Lock()
	defer mu.Unlock()
	return Buffer
}

func (s *Sample) GetBufferData() []byte {
	mu.Lock()
	defer mu.Unlock()
	return Buffer.Bytes()
}

func (s *Sample) SetBufferData(data []byte) {
	mu.Lock()
	defer mu.Unlock()
	Buffer.Write(data)
}

func (s *Sample) MemoryAdd() {
	mu.Lock()
	defer mu.Unlock()
	Mem = append(Mem, s)
}

func (s *Sample) MemoryRemove() {
	mu.Lock()
	defer mu.Unlock()
	for i, instance := range Mem {
		if instance == s {
			lastIndex := len(Mem) - 1
			Mem[i] = Mem[lastIndex]
			Mem = Mem[:lastIndex]
			break
		}
	}
}

func (s *Sample) MemoryUpdate() {
	mu.Lock()
	defer mu.Unlock()

	for i, instance := range Mem {
		if instance.Uuid == s.Uuid {
			Mem[i] = s
			break
		}
	}
}

func (s *Sample) MemoryClear() {
	mu.Lock()
	defer mu.Unlock()
	Mem = []*Sample{}
}

func (s *Sample) MemoryGetAll() []register.Model {
	mu.Lock()
	defer mu.Unlock()
	instances := make([]register.Model, len(Mem))
	for i, instance := range Mem {
		instances[i] = instance
	}
	return instances
}

func (s *Sample) MemoryContains(target register.Model) bool {
	mu.Lock()
	defer mu.Unlock()

	for _, instance := range Mem {
		if instance == target {
			return true
		}
	}
	return false
}

func (s *Sample) MemorySet(models []register.Model) {
	mu.Lock()
	defer mu.Unlock()

	Mem = make([]*Sample, 0, len(models))
	for _, m := range models {
		if instance, ok := m.(*Sample); ok {
			Mem = append(Mem, instance)
		}
	}
}

func (s *Sample) DbInsert(c *hconn.HConn) (model.Message, error) {
	if s.Uuid == uuid.Nil {
		s.WithNewUuid()
	}
	if err := s.Encode(); err != nil {
		return model.Message{}, err
	}

	msg := model.Message{
		Type: model.MessageTypeInsert,
		Entity: register.Entity{
			Version: Version,
			Name:    Name,
			Data:    s.GetBufferData(),
		},
	}
	s.BufferReset()

	if err := c.Send(msg); err != nil {
		return model.Message{}, err
	}

	return c.Receive()
}

func (s *Sample) DbDelete(c *hconn.HConn) (model.Message, error) {
	s.Deleted = true
	if err := s.Encode(); err != nil {
		return model.Message{}, err
	}

	msg := model.Message{
		Type: model.MessageTypeDelete,
		Entity: register.Entity{
			Version: Version,
			Name:    Name,
			Data:    s.GetBufferData(),
		},
	}
	s.BufferReset()

	if err := c.Send(msg); err != nil {
		return model.Message{}, err
	}

	return c.Receive()
}

func (s *Sample) DbUpdate(c *hconn.HConn) (model.Message, error) {
	if s.Uuid == uuid.Nil {
		return model.Message{}, errors.New("cannot update entity without UUID")
	}
	if err := s.Encode(); err != nil {
		return model.Message{}, err
	}

	msg := model.Message{
		Type: model.MessageTypeUpdate,
		Entity: register.Entity{
			Version: Version,
			Name:    Name,
			Data:    s.GetBufferData(),
		},
	}
	s.BufferReset()

	if err := c.Send(msg); err != nil {
		return model.Message{}, err
	}
	return c.Receive()
}

func DbGetAll(c *hconn.HConn) ([]*Sample, error) {
	msg := model.Message{
		Type: model.MessageTypeGetAll,
		Entity: register.Entity{
			Version: Version,
			Name:    Name,
		},
	}

	if err := c.Send(msg); err != nil {
		return nil, err
	}

	resp, err := c.Receive()
	if err != nil {
		return nil, err
	}

	var results []*Sample
	for _, m := range resp.Models {
		if s, ok := m.(*Sample); ok {
			results = append(results, s)
		}
	}

	return results, nil
}
