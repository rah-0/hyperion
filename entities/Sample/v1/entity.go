package SampleV1

// ---------------------------------------------------------------
// The code in this file is autogenerated, do not modify manually!
// ---------------------------------------------------------------

import (
	"bytes"
	"encoding/gob"
	"errors"
	"sort"
	"sync"
	"time"

	"github.com/google/uuid"

	"github.com/rah-0/hyperion/hconn"
	"github.com/rah-0/hyperion/model"
	"github.com/rah-0/hyperion/query"
	"github.com/rah-0/hyperion/register"
)

const (
	Version    = "v1"
	Name       = "Sample"
	DbFileName = "SampleV1.bin"
)

const (
	FieldUuid    = 1
	FieldDeleted = 2
	FieldName    = 3
	FieldSurname = 4
	FieldBirth   = 5
)

var FieldTypes = map[int]string{
	FieldUuid:    "uuid.UUID",
	FieldDeleted: "bool",
	FieldName:    "string",
	FieldSurname: "string",
	FieldBirth:   "time.Time",
}

var Indexes = map[int]any{
	FieldUuid:    map[uuid.UUID][]*Sample{},
	FieldDeleted: map[bool][]*Sample{},
	FieldName:    map[string][]*Sample{},
	FieldSurname: map[string][]*Sample{},
	FieldBirth:   map[time.Time][]*Sample{},
}
var IndexesSorted = []int{
	FieldName,
	FieldSurname,
	FieldBirth,
}

var (
	_              register.Model = (*Sample)(nil)
	mu             sync.Mutex
	Buffer         = new(bytes.Buffer)
	Encoder        = gob.NewEncoder(Buffer)
	Decoder        = gob.NewDecoder(Buffer)
	Mem            []*Sample
	IndexAccessors = map[int]register.IndexAccessor{}
)

func init() {
	// Validate all FieldTypes have an operator set
	for _, typ := range FieldTypes {
		if _, ok := query.OperatorsRegistry[typ]; !ok {
			panic("missing operator set for field type: " + typ)
		}
	}

	// The following process initializes the encoder and decoder by preloading metadata.
	// This prevents metadata from being stored with the first encoded struct.
	// If the metadata were missing or inconsistent, decoding the struct later could fail.
	gob.Register(&Sample{})
	x := New()
	if err := x.Encode(); err != nil {
		panic("failed to encode type metadata: " + err.Error())
	}
	if err := x.Decode(); err != nil {
		panic("failed to decode type metadata: " + err.Error())
	}
	x.BufferReset()

	// IndexAccessors definitions
	IndexAccessors[FieldUuid] = func(val any) []register.Model {
		idx := Indexes[FieldUuid].(map[uuid.UUID][]*Sample)
		v, ok := val.(uuid.UUID)
		if !ok {
			return nil
		}
		return CastToModel(idx[v])
	}
	IndexAccessors[FieldDeleted] = func(val any) []register.Model {
		idx := Indexes[FieldDeleted].(map[bool][]*Sample)
		v, ok := val.(bool)
		if !ok {
			return nil
		}
		return CastToModel(idx[v])
	}
	IndexAccessors[FieldName] = func(val any) []register.Model {
		idx := Indexes[FieldName].(map[string][]*Sample)
		v, ok := val.(string)
		if !ok {
			return nil
		}
		return CastToModel(idx[v])
	}
	IndexAccessors[FieldSurname] = func(val any) []register.Model {
		idx := Indexes[FieldSurname].(map[string][]*Sample)
		v, ok := val.(string)
		if !ok {
			return nil
		}
		return CastToModel(idx[v])
	}
	IndexAccessors[FieldBirth] = func(val any) []register.Model {
		idx := Indexes[FieldBirth].(map[time.Time][]*Sample)
		v, ok := val.(time.Time)
		if !ok {
			return nil
		}
		return CastToModel(idx[v])
	}

	// Initializations
	Mem = []*Sample{}
	register.RegisterEntity(
		&register.EntityBase{
			Version:    Version,
			Name:       Name,
			DbFileName: DbFileName,
		}, &register.EntityExtension{
			New:            New,
			FieldTypes:     FieldTypes,
			Indexes:        Indexes,
			IndexAccessors: IndexAccessors,
			IndexesSorted:  IndexesSorted,
		},
	)
}

type Sample struct {
	Uuid    uuid.UUID `json:",omitzero"`
	Deleted bool      `json:",omitzero"`
	Name    string    `json:"-"`
	Surname string    `json:"-"`
	Birth   time.Time `json:"-"`
}

func New() register.Model {
	return &Sample{}
}

func (s *Sample) WithNewUuid() {
	s.Uuid = uuid.New()
}

func (s *Sample) SetUuid(uuid uuid.UUID) {
	s.Uuid = uuid
}

func (s *Sample) GetUuid() uuid.UUID {
	return s.Uuid
}

func (s *Sample) IsDeleted() bool {
	return s.Deleted
}

func (s *Sample) SetFieldValue(field int, value any) {
	switch field {
	case FieldUuid:
		if v, ok := value.(uuid.UUID); ok {
			s.Uuid = v
		}
	case FieldDeleted:
		if v, ok := value.(bool); ok {
			s.Deleted = v
		}
	case FieldName:
		if v, ok := value.(string); ok {
			s.Name = v
		}
	case FieldSurname:
		if v, ok := value.(string); ok {
			s.Surname = v
		}
	case FieldBirth:
		if v, ok := value.(time.Time); ok {
			s.Birth = v
		}
	}
}

func (s *Sample) GetFieldValue(field int) any {
	switch field {
	case FieldUuid:
		return s.Uuid
	case FieldDeleted:
		return s.Deleted
	case FieldName:
		return s.Name
	case FieldSurname:
		return s.Surname
	case FieldBirth:
		return s.Birth
	}
	return nil
}

func (s *Sample) Encode() error {
	mu.Lock()
	defer mu.Unlock()
	return Encoder.Encode(s)
}

func (s *Sample) Decode() error {
	mu.Lock()
	defer mu.Unlock()
	return Decoder.Decode(s)
}

func (s *Sample) BufferReset() {
	mu.Lock()
	defer mu.Unlock()
	Buffer.Reset()
}

func (s *Sample) GetBuffer() *bytes.Buffer {
	mu.Lock()
	defer mu.Unlock()
	return Buffer
}

func (s *Sample) GetBufferData() []byte {
	mu.Lock()
	defer mu.Unlock()
	return Buffer.Bytes()
}

func (s *Sample) SetBufferData(data []byte) {
	mu.Lock()
	defer mu.Unlock()
	Buffer.Write(data)
}

func (s *Sample) MemoryAdd() {
	mu.Lock()
	defer mu.Unlock()
	Mem = append(Mem, s)

	// Update indexes
	indexUuid := Indexes[FieldUuid].(map[uuid.UUID][]*Sample)
	indexUuid[s.Uuid] = append(indexUuid[s.Uuid], s)
	indexDeleted := Indexes[FieldDeleted].(map[bool][]*Sample)
	indexDeleted[s.Deleted] = append(indexDeleted[s.Deleted], s)
	indexName := Indexes[FieldName].(map[string][]*Sample)
	indexName[s.Name] = insertSorted(indexName[s.Name], s, FieldName, FieldTypes[FieldName])
	indexSurname := Indexes[FieldSurname].(map[string][]*Sample)
	indexSurname[s.Surname] = insertSorted(indexSurname[s.Surname], s, FieldSurname, FieldTypes[FieldSurname])
	indexBirth := Indexes[FieldBirth].(map[time.Time][]*Sample)
	indexBirth[s.Birth] = insertSorted(indexBirth[s.Birth], s, FieldBirth, FieldTypes[FieldBirth])
}

func (s *Sample) MemoryRemove() {
	mu.Lock()
	defer mu.Unlock()
	for i, instance := range Mem {
		if instance == s {
			lastIndex := len(Mem) - 1
			Mem[i] = Mem[lastIndex]
			Mem = Mem[:lastIndex]
			break
		}
	}

	// Remove from indexes
	indexUuid := Indexes[FieldUuid].(map[uuid.UUID][]*Sample)
	indexUuid[s.Uuid] = removeFromIndex(indexUuid[s.Uuid], s)
	indexDeleted := Indexes[FieldDeleted].(map[bool][]*Sample)
	indexDeleted[s.Deleted] = removeFromIndex(indexDeleted[s.Deleted], s)
	indexName := Indexes[FieldName].(map[string][]*Sample)
	indexName[s.Name] = removeFromIndex(indexName[s.Name], s)
	indexSurname := Indexes[FieldSurname].(map[string][]*Sample)
	indexSurname[s.Surname] = removeFromIndex(indexSurname[s.Surname], s)
	indexBirth := Indexes[FieldBirth].(map[time.Time][]*Sample)
	indexBirth[s.Birth] = removeFromIndex(indexBirth[s.Birth], s)
}

func (s *Sample) MemoryUpdate() {
	mu.Lock()
	defer mu.Unlock()

	for i, old := range Mem {
		if old.Uuid != s.Uuid {
			continue
		}
		if old.Uuid != s.Uuid {
			indexUuid := Indexes[FieldUuid].(map[uuid.UUID][]*Sample)
			indexUuid[old.Uuid] = removeFromIndex(indexUuid[old.Uuid], old)
			indexUuid[s.Uuid] = append(indexUuid[s.Uuid], s)
		}
		if old.Deleted != s.Deleted {
			indexDeleted := Indexes[FieldDeleted].(map[bool][]*Sample)
			indexDeleted[old.Deleted] = removeFromIndex(indexDeleted[old.Deleted], old)
			indexDeleted[s.Deleted] = append(indexDeleted[s.Deleted], s)
		}
		if old.Name != s.Name {
			indexName := Indexes[FieldName].(map[string][]*Sample)
			indexName[old.Name] = removeFromIndex(indexName[old.Name], old)
			indexName[s.Name] = insertSorted(indexName[s.Name], s, FieldName, FieldTypes[FieldName])
		}
		if old.Surname != s.Surname {
			indexSurname := Indexes[FieldSurname].(map[string][]*Sample)
			indexSurname[old.Surname] = removeFromIndex(indexSurname[old.Surname], old)
			indexSurname[s.Surname] = insertSorted(indexSurname[s.Surname], s, FieldSurname, FieldTypes[FieldSurname])
		}
		if old.Birth != s.Birth {
			indexBirth := Indexes[FieldBirth].(map[time.Time][]*Sample)
			indexBirth[old.Birth] = removeFromIndex(indexBirth[old.Birth], old)
			indexBirth[s.Birth] = insertSorted(indexBirth[s.Birth], s, FieldBirth, FieldTypes[FieldBirth])
		}
		Mem[i] = s
		break
	}
}

func (s *Sample) MemoryClear() {
	mu.Lock()
	defer mu.Unlock()

	Mem = []*Sample{}

	Indexes[FieldUuid] = map[uuid.UUID][]*Sample{}
	Indexes[FieldDeleted] = map[bool][]*Sample{}
	Indexes[FieldName] = map[string][]*Sample{}
	Indexes[FieldSurname] = map[string][]*Sample{}
	Indexes[FieldBirth] = map[time.Time][]*Sample{}
}

func (s *Sample) MemoryGetAll() []register.Model {
	mu.Lock()
	defer mu.Unlock()
	instances := make([]register.Model, len(Mem))
	for i, instance := range Mem {
		instances[i] = instance
	}
	return instances
}

func (s *Sample) MemoryContains(target register.Model) bool {
	mu.Lock()
	defer mu.Unlock()

	for _, instance := range Mem {
		if instance == target {
			return true
		}
	}
	return false
}

func (s *Sample) DbInsert(c *hconn.HConn) error {
	if s.Uuid == uuid.Nil {
		s.WithNewUuid()
	}
	if err := s.Encode(); err != nil {
		return err
	}

	msg := model.Message{
		Type: model.MessageTypeInsert,
		Entity: register.EntityBase{
			Version: Version,
			Name:    Name,
			Data:    s.GetBufferData(),
		},
	}
	s.BufferReset()

	if err := c.Send(msg); err != nil {
		return err
	}

	resp, err := c.Receive()
	if err != nil {
		return err
	}
	if resp.Status == model.StatusError {
		return errors.New(resp.String)
	}

	return nil
}

func (s *Sample) DbDelete(c *hconn.HConn) error {
	s.Deleted = true
	if err := s.Encode(); err != nil {
		return err
	}

	msg := model.Message{
		Type: model.MessageTypeDelete,
		Entity: register.EntityBase{
			Version: Version,
			Name:    Name,
			Data:    s.GetBufferData(),
		},
	}
	s.BufferReset()

	if err := c.Send(msg); err != nil {
		return err
	}

	resp, err := c.Receive()
	if err != nil {
		return err
	}
	if resp.Status == model.StatusError {
		return errors.New(resp.String)
	}

	return nil
}

func (s *Sample) DbUpdate(c *hconn.HConn) error {
	if s.Uuid == uuid.Nil {
		return model.ErrQueryEntityNoUuid
	}
	if err := s.Encode(); err != nil {
		return err
	}

	msg := model.Message{
		Type: model.MessageTypeUpdate,
		Entity: register.EntityBase{
			Version: Version,
			Name:    Name,
			Data:    s.GetBufferData(),
		},
	}
	s.BufferReset()

	if err := c.Send(msg); err != nil {
		return err
	}

	resp, err := c.Receive()
	if err != nil {
		return err
	}
	if resp.Status == model.StatusError {
		return errors.New(resp.String)
	}

	return nil
}

func DbGetAll(c *hconn.HConn) ([]*Sample, error) {
	msg := model.Message{
		Type: model.MessageTypeGetAll,
		Entity: register.EntityBase{
			Version: Version,
			Name:    Name,
		},
	}

	if err := c.Send(msg); err != nil {
		return nil, err
	}

	resp, err := c.Receive()
	if err != nil {
		return nil, err
	}

	if resp.Status == model.StatusError {
		return nil, errors.New(resp.String)
	}

	return CastToSample(resp.Models), nil
}

func DbQuery(c *hconn.HConn, q *query.Query) ([]*Sample, error) {
	msg := model.Message{
		Type: model.MessageTypeQuery,
		Entity: register.EntityBase{
			Version: Version,
			Name:    Name,
		},
		Query: q,
	}

	if err := c.Send(msg); err != nil {
		return nil, err
	}

	resp, err := c.Receive()
	if err != nil {
		return nil, err
	}

	if resp.Status == model.StatusError {
		return nil, errors.New(resp.String)
	}

	return CastToSample(resp.Models), nil
}

func CastToSample(models []register.Model) []*Sample {
	out := make([]*Sample, len(models))
	for i, m := range models {
		out[i] = m.(*Sample)
	}
	return out
}

func CastToModel(items []*Sample) []register.Model {
	out := make([]register.Model, len(items))
	for i, s := range items {
		out[i] = s
	}
	return out
}

func removeFromIndex(list []*Sample, target *Sample) []*Sample {
	for i, item := range list {
		if item == target {
			last := len(list) - 1
			copy(list[i:], list[i+1:])
			return list[:last]
		}
	}
	return list
}

func insertSorted(list []*Sample, val *Sample, field int, fieldType string) []*Sample {
	opSet := query.OperatorsRegistry[fieldType].(map[query.OperatorType]func(a, b any) bool)
	less := opSet[query.OperatorTypeLesser]

	v := val.GetFieldValue(field)
	i := sort.Search(len(list), func(j int) bool {
		return !less(list[j].GetFieldValue(field), v)
	})

	list = append(list, nil)
	copy(list[i+1:], list[i:])
	list[i] = val
	return list
}
