package template

import (
	"path/filepath"
	"strconv"
	"strings"

	. "github.com/rah-0/hyperion/util"
)

func TemplateEntity(s StructDef, v string) (string, error) {
	mn, err := GetModuleName("go.mod")
	if err != nil {
		return "", err
	}

	template := "package " + s.Name + "\n"
	template += "// The code in this file is autogenerated, do not modify manually!" + "\n\n"

	template += "import (\n"
	template += `"bytes"` + "\n"
	template += `"encoding/gob"` + "\n"
	template += `"sync"` + "\n\n"
	template += `"github.com/google/uuid"` + "\n\n"
	template += `. "` + filepath.Join(mn, "hconn") + `"` + "\n"
	template += `. "` + filepath.Join(mn, "model") + `"` + "\n"
	template += `. "` + filepath.Join(mn, "register") + `"` + "\n"
	template += ")\n"

	template += "const (\n"
	template += `Version = "` + v + `"` + "\n"
	template += `Name = "` + s.Name + `"` + "\n"
	template += `DbFileName = "` + s.Name + strings.ToUpper(v) + `.bin"` + "\n"
	template += ")\n\n"

	i := 1
	template += "var Fields = map[string]int{" + "\n"
	for _, f := range s.Fields {
		template += `"` + f.Name + `": ` + strconv.Itoa(i) + "," + "\n"
		i++
	}
	template += "}" + "\n\n"

	template += "var (" + "\n"
	template += "_ Model = (*" + s.Name + ")(nil)" + "\n"
	template += "mu sync.Mutex" + "\n"
	template += "Buffer = new(bytes.Buffer)" + "\n"
	template += "Encoder = gob.NewEncoder(Buffer)" + "\n"
	template += "Decoder = gob.NewDecoder(Buffer)" + "\n"
	template += "Mem []*Sample\n"
	template += ")" + "\n\n"

	template += "func init() {\n"
	template += "gob.Register(" + s.Name + "{})\n\n"
	template += "//The following process initializes the encoder and decoder by preloading metadata." + "\n"
	template += "//This prevents metadata from being stored with the first encoded struct." + "\n"
	template += "//If the metadata were missing or inconsistent, decoding the struct later could fail." + "\n"
	template += "x := New()\n"
	template += "if err := x.Encode(); err != nil {\n"
	template += `panic("failed to encode type metadata: " + err.Error())` + "\n"
	template += "}\n"
	template += "if err := x.Decode(); err != nil {\n"
	template += `panic("failed to decode type metadata: " + err.Error())` + "\n"
	template += "}\n"
	template += "x.BufferReset()\n\n"
	template += "Mem = []*" + s.Name + "{}\n\n"
	template += "RegisterEntity(&Entity{\n"
	template += "Version: Version,\n"
	template += "Name: Name,\n"
	template += "DbFileName: DbFileName,\n"
	template += "Fields: Fields,\n"
	template += "New: New,\n"
	template += "})\n"
	template += "}\n\n"

	template += "type " + s.Name + " struct {\n"
	for _, f := range s.Fields {
		template += f.Name + " " + f.Type + "\n"
	}
	template += "}\n"

	template += "func New() Model {\n"
	template += "return &" + s.Name + "{\n"
	template += "}\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") WithNewUuid() {\n"
	template += "s.Uuid = uuid.New()\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") SetUuid(uuid uuid.UUID) {\n"
	template += "s.Uuid = uuid\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") GetUuid() uuid.UUID {\n"
	template += "return s.Uuid\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") SetFieldValue(fieldName string, value any) {" + "\n"
	template += "switch Fields[fieldName] {" + "\n"
	i = 1
	for _, f := range s.Fields {
		template += "case " + strconv.Itoa(i) + ":\n"
		template += "if v, ok := value.(" + f.Type + "); ok {" + "\n"
		template += "s." + f.Name + "=v" + "\n"
		template += "}" + "\n"
		i++
	}
	template += "}}" + "\n\n"

	template += "func (s *" + s.Name + ") GetFieldValue(fieldName string) any {" + "\n"
	template += "switch Fields[fieldName] {" + "\n"
	i = 1
	for _, f := range s.Fields {
		template += "case " + strconv.Itoa(i) + ":\n"
		template += "return s." + f.Name + "\n"
		i++
	}
	template += "}" + "\n"
	template += "return nil" + "\n"
	template += "}" + "\n\n"

	template += "func (s *" + s.Name + ") Encode() error {\n"
	template += "mu.Lock()\n"
	template += "defer mu.Unlock()\n"
	template += "return Encoder.Encode(s)\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") Decode() error {\n"
	template += "mu.Lock()\n"
	template += "defer mu.Unlock()\n"
	template += "return Decoder.Decode(s)\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") BufferReset() {\n"
	template += "mu.Lock()\n"
	template += "defer mu.Unlock()\n"
	template += "Buffer.Reset()\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") GetBuffer() *bytes.Buffer {\n"
	template += "mu.Lock()\n"
	template += "defer mu.Unlock()\n"
	template += "return Buffer\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") GetBufferData() []byte {\n"
	template += "mu.Lock()\n"
	template += "defer mu.Unlock()\n"
	template += "return Buffer.Bytes()\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") SetBufferData(data []byte) {\n"
	template += "mu.Lock()\n"
	template += "defer mu.Unlock()\n"
	template += "Buffer.Write(data)\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") MemoryAdd() {\n"
	template += "mu.Lock()\n"
	template += "defer mu.Unlock()\n"
	template += "Mem = append(Mem, s)\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") MemoryRemove() bool {\n"
	template += "mu.Lock()\n"
	template += "defer mu.Unlock()\n"
	template += "for i, instance := range Mem {\n"
	template += "if instance == s {\n"
	template += "lastIndex := len(Mem) - 1\n"
	template += "Mem[i] = Mem[lastIndex]\n"
	template += "Mem = Mem[:lastIndex]\n"
	template += "return true\n"
	template += "}\n"
	template += "}\n"
	template += "return false\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") MemoryClear() {\n"
	template += "mu.Lock()\n"
	template += "defer mu.Unlock()\n"
	template += "Mem = []*" + s.Name + "{}\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") MemoryGetAll() []Model {\n"
	template += "mu.Lock()\n"
	template += "defer mu.Unlock()\n"
	template += "instances := make([]Model, len(Mem))\n"
	template += "for i, instance := range Mem {\n"
	template += "instances[i] = instance\n"
	template += "}\n"
	template += "return instances\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") MemoryContains(target Model) bool {\n"
	template += "mu.Lock()\n"
	template += "defer mu.Unlock()\n\n"
	template += "for _, instance := range Mem {\n"
	template += "if instance == target {\n"
	template += "return true\n"
	template += "}\n"
	template += "}\n"
	template += "return false\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") MemorySet(models []Model) {\n"
	template += "mu.Lock()\n"
	template += "defer mu.Unlock()\n\n"
	template += "Mem = make([]*" + s.Name + ", 0, len(models))\n"
	template += "for _, model := range models {\n"
	template += "if instance, ok := model.(*" + s.Name + "); ok {\n"
	template += "Mem = append(Mem, instance)\n"
	template += "}\n"
	template += "}\n"
	template += "}\n\n"

	template += "func (s *" + s.Name + ") DbInsert(c *HConn) (Message, error) {\n"
	template += "if s.Uuid == uuid.Nil {\n"
	template += "s.WithNewUuid()\n"
	template += "}\n"
	template += "if err := s.Encode(); err != nil {\n"
	template += "return Message{}, err\n"
	template += "}\n\n"
	template += "msg := Message{\n"
	template += "Type: MessageTypeInsert,\n"
	template += "Entity: Entity{\n"
	template += "Version: Version,\n"
	template += "Name: Name,\n"
	template += "Data: s.GetBufferData(),\n"
	template += "},\n"
	template += "}\n"
	template += "s.BufferReset()\n\n"
	template += "if err := c.Send(msg); err != nil {\n"
	template += "return Message{}, err\n"
	template += "}\n"
	template += "return c.Receive()\n"
	template += "}\n\n"

	return template, nil
}

func TemplateMigrations(sPrevious StructDef, sCurrent StructDef, vPrevious string, vCurrent string) (string, error) {
	mn, err := GetModuleName("go.mod")
	if err != nil {
		return "", err
	}

	template := "package " + sCurrent.Name + "\n"
	template += "// NOTE: this file is generated only once, if you want to update it you can delete it and run the generator again!" + "\n\n"

	template += "import (\n"
	template += vPrevious + ` "` + filepath.Join(mn, "entities", sCurrent.Name, vPrevious) + `"`
	template += ")\n"

	template += `func Upgrade(previous ` + vPrevious + `.` + sPrevious.Name + `) (current ` + sCurrent.Name + `){` + "\n"
	template += `panic("Function not implemented")` + "\n"
	template += "}\n\n"

	template += `func Downgrade(current ` + sCurrent.Name + `) (previous ` + vPrevious + `.` + sPrevious.Name + `){` + "\n"
	template += `panic("Function not implemented")` + "\n"
	template += "}\n"

	return template, nil
}

func TemplateMigrationsTests(sCurrent StructDef) (string, error) {
	template := "package " + sCurrent.Name + "\n"
	template += "// NOTE: this file is generated only once, if you want to update it you can delete it and run the generator again!" + "\n\n"

	template += "import (\n"
	template += `"testing"`
	template += ")\n"

	template += `func TestUpgrade(t *testing.T) {` + "\n"
	template += `t.Fatal("Test not implemented")` + "\n"
	template += "}\n\n"

	template += `func TestDowngrade(t *testing.T) {` + "\n"
	template += `t.Fatal("Test not implemented")` + "\n"
	template += "}\n\n"

	return template, nil
}
